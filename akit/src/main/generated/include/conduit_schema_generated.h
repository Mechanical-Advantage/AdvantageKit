// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CONDUITSCHEMA_ORG_LITTLETONROBOTICS_CONDUIT_SCHEMA_H_
#define FLATBUFFERS_GENERATED_CONDUITSCHEMA_ORG_LITTLETONROBOTICS_CONDUIT_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace org {
namespace littletonrobotics {
namespace conduit {
namespace schema {

struct Joystick;

struct DSData;

struct PDPData;

struct Vector3;

struct Vector4;

struct SystemData;

struct CoreInputs;

inline const ::flatbuffers::TypeTable *JoystickTypeTable();

inline const ::flatbuffers::TypeTable *DSDataTypeTable();

inline const ::flatbuffers::TypeTable *PDPDataTypeTable();

inline const ::flatbuffers::TypeTable *Vector3TypeTable();

inline const ::flatbuffers::TypeTable *Vector4TypeTable();

inline const ::flatbuffers::TypeTable *SystemDataTypeTable();

inline const ::flatbuffers::TypeTable *CoreInputsTypeTable();

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Joystick FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t name_[256];
  uint8_t type_;
  int8_t padding0__;
  int16_t axis_count_;
  uint8_t axis_types_[12];
  float axis_values_[12];
  uint8_t button_count_;
  int8_t padding1__;  int16_t padding2__;
  int32_t buttons_;
  int16_t pov_count_;
  uint8_t pov_values_[8];
  uint8_t is_gamepad_;
  int8_t padding3__;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return JoystickTypeTable();
  }
  Joystick()
      : name_(),
        type_(0),
        padding0__(0),
        axis_count_(0),
        axis_types_(),
        axis_values_(),
        button_count_(0),
        padding1__(0),
        padding2__(0),
        buttons_(0),
        pov_count_(0),
        pov_values_(),
        is_gamepad_(0),
        padding3__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
  }
  Joystick(uint8_t _type, int16_t _axis_count, uint8_t _button_count, int32_t _buttons, int16_t _pov_count, bool _is_gamepad)
      : name_(),
        type_(::flatbuffers::EndianScalar(_type)),
        padding0__(0),
        axis_count_(::flatbuffers::EndianScalar(_axis_count)),
        axis_types_(),
        axis_values_(),
        button_count_(::flatbuffers::EndianScalar(_button_count)),
        padding1__(0),
        padding2__(0),
        buttons_(::flatbuffers::EndianScalar(_buttons)),
        pov_count_(::flatbuffers::EndianScalar(_pov_count)),
        pov_values_(),
        is_gamepad_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_is_gamepad))),
        padding3__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
  }
  Joystick(::flatbuffers::span<const uint8_t, 256> _name, uint8_t _type, int16_t _axis_count, ::flatbuffers::span<const uint8_t, 12> _axis_types, ::flatbuffers::span<const float, 12> _axis_values, uint8_t _button_count, int32_t _buttons, int16_t _pov_count, ::flatbuffers::span<const uint8_t, 8> _pov_values, bool _is_gamepad)
      : type_(::flatbuffers::EndianScalar(_type)),
        padding0__(0),
        axis_count_(::flatbuffers::EndianScalar(_axis_count)),
        button_count_(::flatbuffers::EndianScalar(_button_count)),
        padding1__(0),
        padding2__(0),
        buttons_(::flatbuffers::EndianScalar(_buttons)),
        pov_count_(::flatbuffers::EndianScalar(_pov_count)),
        is_gamepad_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_is_gamepad))),
        padding3__(0) {
    ::flatbuffers::CastToArray(name_).CopyFromSpan(_name);
    (void)padding0__;
    ::flatbuffers::CastToArray(axis_types_).CopyFromSpan(_axis_types);
    ::flatbuffers::CastToArray(axis_values_).CopyFromSpan(_axis_values);
    (void)padding1__;
    (void)padding2__;
    ::flatbuffers::CastToArray(pov_values_).CopyFromSpan(_pov_values);
    (void)padding3__;
  }
  const ::flatbuffers::Array<uint8_t, 256> *name() const {
    return &::flatbuffers::CastToArray(name_);
  }
  ::flatbuffers::Array<uint8_t, 256> *mutable_name() {
    return &::flatbuffers::CastToArray(name_);
  }
  uint8_t type() const {
    return ::flatbuffers::EndianScalar(type_);
  }
  void mutate_type(uint8_t _type) {
    ::flatbuffers::WriteScalar(&type_, _type);
  }
  int16_t axis_count() const {
    return ::flatbuffers::EndianScalar(axis_count_);
  }
  void mutate_axis_count(int16_t _axis_count) {
    ::flatbuffers::WriteScalar(&axis_count_, _axis_count);
  }
  const ::flatbuffers::Array<uint8_t, 12> *axis_types() const {
    return &::flatbuffers::CastToArray(axis_types_);
  }
  ::flatbuffers::Array<uint8_t, 12> *mutable_axis_types() {
    return &::flatbuffers::CastToArray(axis_types_);
  }
  const ::flatbuffers::Array<float, 12> *axis_values() const {
    return &::flatbuffers::CastToArray(axis_values_);
  }
  ::flatbuffers::Array<float, 12> *mutable_axis_values() {
    return &::flatbuffers::CastToArray(axis_values_);
  }
  uint8_t button_count() const {
    return ::flatbuffers::EndianScalar(button_count_);
  }
  void mutate_button_count(uint8_t _button_count) {
    ::flatbuffers::WriteScalar(&button_count_, _button_count);
  }
  int32_t buttons() const {
    return ::flatbuffers::EndianScalar(buttons_);
  }
  void mutate_buttons(int32_t _buttons) {
    ::flatbuffers::WriteScalar(&buttons_, _buttons);
  }
  int16_t pov_count() const {
    return ::flatbuffers::EndianScalar(pov_count_);
  }
  void mutate_pov_count(int16_t _pov_count) {
    ::flatbuffers::WriteScalar(&pov_count_, _pov_count);
  }
  const ::flatbuffers::Array<uint8_t, 8> *pov_values() const {
    return &::flatbuffers::CastToArray(pov_values_);
  }
  ::flatbuffers::Array<uint8_t, 8> *mutable_pov_values() {
    return &::flatbuffers::CastToArray(pov_values_);
  }
  bool is_gamepad() const {
    return ::flatbuffers::EndianScalar(is_gamepad_) != 0;
  }
  void mutate_is_gamepad(bool _is_gamepad) {
    ::flatbuffers::WriteScalar(&is_gamepad_, static_cast<uint8_t>(_is_gamepad));
  }
};
FLATBUFFERS_STRUCT_END(Joystick, 340);

inline bool operator==(const Joystick &lhs, const Joystick &rhs) {
  return
      (*lhs.name() == *rhs.name()) &&
      (lhs.type() == rhs.type()) &&
      (lhs.axis_count() == rhs.axis_count()) &&
      (*lhs.axis_types() == *rhs.axis_types()) &&
      (*lhs.axis_values() == *rhs.axis_values()) &&
      (lhs.button_count() == rhs.button_count()) &&
      (lhs.buttons() == rhs.buttons()) &&
      (lhs.pov_count() == rhs.pov_count()) &&
      (*lhs.pov_values() == *rhs.pov_values()) &&
      (lhs.is_gamepad() == rhs.is_gamepad());
}

inline bool operator!=(const Joystick &lhs, const Joystick &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DSData FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t alliance_station_;
  uint8_t event_name_[64];
  uint16_t game_specific_message_size_;
  uint8_t game_specific_message_[64];
  uint16_t match_number_;
  uint8_t replay_number_;
  int8_t padding0__;  int16_t padding1__;
  int32_t match_type_;
  int32_t control_word_;
  int32_t padding2__;
  double match_time_;
  org::littletonrobotics::conduit::schema::Joystick joysticks_[6];

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DSDataTypeTable();
  }
  DSData()
      : alliance_station_(0),
        event_name_(),
        game_specific_message_size_(0),
        game_specific_message_(),
        match_number_(0),
        replay_number_(0),
        padding0__(0),
        padding1__(0),
        match_type_(0),
        control_word_(0),
        padding2__(0),
        match_time_(0),
        joysticks_() {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  DSData(int32_t _alliance_station, uint16_t _game_specific_message_size, uint16_t _match_number, uint8_t _replay_number, int32_t _match_type, int32_t _control_word, double _match_time)
      : alliance_station_(::flatbuffers::EndianScalar(_alliance_station)),
        event_name_(),
        game_specific_message_size_(::flatbuffers::EndianScalar(_game_specific_message_size)),
        game_specific_message_(),
        match_number_(::flatbuffers::EndianScalar(_match_number)),
        replay_number_(::flatbuffers::EndianScalar(_replay_number)),
        padding0__(0),
        padding1__(0),
        match_type_(::flatbuffers::EndianScalar(_match_type)),
        control_word_(::flatbuffers::EndianScalar(_control_word)),
        padding2__(0),
        match_time_(::flatbuffers::EndianScalar(_match_time)),
        joysticks_() {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  DSData(int32_t _alliance_station, ::flatbuffers::span<const uint8_t, 64> _event_name, uint16_t _game_specific_message_size, ::flatbuffers::span<const uint8_t, 64> _game_specific_message, uint16_t _match_number, uint8_t _replay_number, int32_t _match_type, int32_t _control_word, double _match_time, ::flatbuffers::span<const org::littletonrobotics::conduit::schema::Joystick, 6> _joysticks)
      : alliance_station_(::flatbuffers::EndianScalar(_alliance_station)),
        game_specific_message_size_(::flatbuffers::EndianScalar(_game_specific_message_size)),
        match_number_(::flatbuffers::EndianScalar(_match_number)),
        replay_number_(::flatbuffers::EndianScalar(_replay_number)),
        padding0__(0),
        padding1__(0),
        match_type_(::flatbuffers::EndianScalar(_match_type)),
        control_word_(::flatbuffers::EndianScalar(_control_word)),
        padding2__(0),
        match_time_(::flatbuffers::EndianScalar(_match_time)) {
    ::flatbuffers::CastToArray(event_name_).CopyFromSpan(_event_name);
    ::flatbuffers::CastToArray(game_specific_message_).CopyFromSpan(_game_specific_message);
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    ::flatbuffers::CastToArray(joysticks_).CopyFromSpan(_joysticks);
  }
  int32_t alliance_station() const {
    return ::flatbuffers::EndianScalar(alliance_station_);
  }
  void mutate_alliance_station(int32_t _alliance_station) {
    ::flatbuffers::WriteScalar(&alliance_station_, _alliance_station);
  }
  const ::flatbuffers::Array<uint8_t, 64> *event_name() const {
    return &::flatbuffers::CastToArray(event_name_);
  }
  ::flatbuffers::Array<uint8_t, 64> *mutable_event_name() {
    return &::flatbuffers::CastToArray(event_name_);
  }
  uint16_t game_specific_message_size() const {
    return ::flatbuffers::EndianScalar(game_specific_message_size_);
  }
  void mutate_game_specific_message_size(uint16_t _game_specific_message_size) {
    ::flatbuffers::WriteScalar(&game_specific_message_size_, _game_specific_message_size);
  }
  const ::flatbuffers::Array<uint8_t, 64> *game_specific_message() const {
    return &::flatbuffers::CastToArray(game_specific_message_);
  }
  ::flatbuffers::Array<uint8_t, 64> *mutable_game_specific_message() {
    return &::flatbuffers::CastToArray(game_specific_message_);
  }
  uint16_t match_number() const {
    return ::flatbuffers::EndianScalar(match_number_);
  }
  void mutate_match_number(uint16_t _match_number) {
    ::flatbuffers::WriteScalar(&match_number_, _match_number);
  }
  uint8_t replay_number() const {
    return ::flatbuffers::EndianScalar(replay_number_);
  }
  void mutate_replay_number(uint8_t _replay_number) {
    ::flatbuffers::WriteScalar(&replay_number_, _replay_number);
  }
  int32_t match_type() const {
    return ::flatbuffers::EndianScalar(match_type_);
  }
  void mutate_match_type(int32_t _match_type) {
    ::flatbuffers::WriteScalar(&match_type_, _match_type);
  }
  int32_t control_word() const {
    return ::flatbuffers::EndianScalar(control_word_);
  }
  void mutate_control_word(int32_t _control_word) {
    ::flatbuffers::WriteScalar(&control_word_, _control_word);
  }
  double match_time() const {
    return ::flatbuffers::EndianScalar(match_time_);
  }
  void mutate_match_time(double _match_time) {
    ::flatbuffers::WriteScalar(&match_time_, _match_time);
  }
  const ::flatbuffers::Array<org::littletonrobotics::conduit::schema::Joystick, 6> *joysticks() const {
    return &::flatbuffers::CastToArray(joysticks_);
  }
  ::flatbuffers::Array<org::littletonrobotics::conduit::schema::Joystick, 6> *mutable_joysticks() {
    return &::flatbuffers::CastToArray(joysticks_);
  }
};
FLATBUFFERS_STRUCT_END(DSData, 2200);

inline bool operator==(const DSData &lhs, const DSData &rhs) {
  return
      (lhs.alliance_station() == rhs.alliance_station()) &&
      (*lhs.event_name() == *rhs.event_name()) &&
      (lhs.game_specific_message_size() == rhs.game_specific_message_size()) &&
      (*lhs.game_specific_message() == *rhs.game_specific_message()) &&
      (lhs.match_number() == rhs.match_number()) &&
      (lhs.replay_number() == rhs.replay_number()) &&
      (lhs.match_type() == rhs.match_type()) &&
      (lhs.control_word() == rhs.control_word()) &&
      (lhs.match_time() == rhs.match_time()) &&
      (*lhs.joysticks() == *rhs.joysticks());
}

inline bool operator!=(const DSData &lhs, const DSData &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) PDPData FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t handle_;
  int32_t channel_count_;
  int32_t type_;
  int32_t module_id_;
  uint32_t faults_;
  uint32_t sticky_faults_;
  double temperature_;
  double voltage_;
  double channel_current_[24];
  double total_current_;
  double total_power_;
  double total_energy_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PDPDataTypeTable();
  }
  PDPData()
      : handle_(0),
        channel_count_(0),
        type_(0),
        module_id_(0),
        faults_(0),
        sticky_faults_(0),
        temperature_(0),
        voltage_(0),
        channel_current_(),
        total_current_(0),
        total_power_(0),
        total_energy_(0) {
  }
  PDPData(int32_t _handle, int32_t _channel_count, int32_t _type, int32_t _module_id, uint32_t _faults, uint32_t _sticky_faults, double _temperature, double _voltage, double _total_current, double _total_power, double _total_energy)
      : handle_(::flatbuffers::EndianScalar(_handle)),
        channel_count_(::flatbuffers::EndianScalar(_channel_count)),
        type_(::flatbuffers::EndianScalar(_type)),
        module_id_(::flatbuffers::EndianScalar(_module_id)),
        faults_(::flatbuffers::EndianScalar(_faults)),
        sticky_faults_(::flatbuffers::EndianScalar(_sticky_faults)),
        temperature_(::flatbuffers::EndianScalar(_temperature)),
        voltage_(::flatbuffers::EndianScalar(_voltage)),
        channel_current_(),
        total_current_(::flatbuffers::EndianScalar(_total_current)),
        total_power_(::flatbuffers::EndianScalar(_total_power)),
        total_energy_(::flatbuffers::EndianScalar(_total_energy)) {
  }
  PDPData(int32_t _handle, int32_t _channel_count, int32_t _type, int32_t _module_id, uint32_t _faults, uint32_t _sticky_faults, double _temperature, double _voltage, ::flatbuffers::span<const double, 24> _channel_current, double _total_current, double _total_power, double _total_energy)
      : handle_(::flatbuffers::EndianScalar(_handle)),
        channel_count_(::flatbuffers::EndianScalar(_channel_count)),
        type_(::flatbuffers::EndianScalar(_type)),
        module_id_(::flatbuffers::EndianScalar(_module_id)),
        faults_(::flatbuffers::EndianScalar(_faults)),
        sticky_faults_(::flatbuffers::EndianScalar(_sticky_faults)),
        temperature_(::flatbuffers::EndianScalar(_temperature)),
        voltage_(::flatbuffers::EndianScalar(_voltage)),
        total_current_(::flatbuffers::EndianScalar(_total_current)),
        total_power_(::flatbuffers::EndianScalar(_total_power)),
        total_energy_(::flatbuffers::EndianScalar(_total_energy)) {
    ::flatbuffers::CastToArray(channel_current_).CopyFromSpan(_channel_current);
  }
  int32_t handle() const {
    return ::flatbuffers::EndianScalar(handle_);
  }
  void mutate_handle(int32_t _handle) {
    ::flatbuffers::WriteScalar(&handle_, _handle);
  }
  int32_t channel_count() const {
    return ::flatbuffers::EndianScalar(channel_count_);
  }
  void mutate_channel_count(int32_t _channel_count) {
    ::flatbuffers::WriteScalar(&channel_count_, _channel_count);
  }
  int32_t type() const {
    return ::flatbuffers::EndianScalar(type_);
  }
  void mutate_type(int32_t _type) {
    ::flatbuffers::WriteScalar(&type_, _type);
  }
  int32_t module_id() const {
    return ::flatbuffers::EndianScalar(module_id_);
  }
  void mutate_module_id(int32_t _module_id) {
    ::flatbuffers::WriteScalar(&module_id_, _module_id);
  }
  uint32_t faults() const {
    return ::flatbuffers::EndianScalar(faults_);
  }
  void mutate_faults(uint32_t _faults) {
    ::flatbuffers::WriteScalar(&faults_, _faults);
  }
  uint32_t sticky_faults() const {
    return ::flatbuffers::EndianScalar(sticky_faults_);
  }
  void mutate_sticky_faults(uint32_t _sticky_faults) {
    ::flatbuffers::WriteScalar(&sticky_faults_, _sticky_faults);
  }
  double temperature() const {
    return ::flatbuffers::EndianScalar(temperature_);
  }
  void mutate_temperature(double _temperature) {
    ::flatbuffers::WriteScalar(&temperature_, _temperature);
  }
  double voltage() const {
    return ::flatbuffers::EndianScalar(voltage_);
  }
  void mutate_voltage(double _voltage) {
    ::flatbuffers::WriteScalar(&voltage_, _voltage);
  }
  const ::flatbuffers::Array<double, 24> *channel_current() const {
    return &::flatbuffers::CastToArray(channel_current_);
  }
  ::flatbuffers::Array<double, 24> *mutable_channel_current() {
    return &::flatbuffers::CastToArray(channel_current_);
  }
  double total_current() const {
    return ::flatbuffers::EndianScalar(total_current_);
  }
  void mutate_total_current(double _total_current) {
    ::flatbuffers::WriteScalar(&total_current_, _total_current);
  }
  double total_power() const {
    return ::flatbuffers::EndianScalar(total_power_);
  }
  void mutate_total_power(double _total_power) {
    ::flatbuffers::WriteScalar(&total_power_, _total_power);
  }
  double total_energy() const {
    return ::flatbuffers::EndianScalar(total_energy_);
  }
  void mutate_total_energy(double _total_energy) {
    ::flatbuffers::WriteScalar(&total_energy_, _total_energy);
  }
};
FLATBUFFERS_STRUCT_END(PDPData, 256);

inline bool operator==(const PDPData &lhs, const PDPData &rhs) {
  return
      (lhs.handle() == rhs.handle()) &&
      (lhs.channel_count() == rhs.channel_count()) &&
      (lhs.type() == rhs.type()) &&
      (lhs.module_id() == rhs.module_id()) &&
      (lhs.faults() == rhs.faults()) &&
      (lhs.sticky_faults() == rhs.sticky_faults()) &&
      (lhs.temperature() == rhs.temperature()) &&
      (lhs.voltage() == rhs.voltage()) &&
      (*lhs.channel_current() == *rhs.channel_current()) &&
      (lhs.total_current() == rhs.total_current()) &&
      (lhs.total_power() == rhs.total_power()) &&
      (lhs.total_energy() == rhs.total_energy());
}

inline bool operator!=(const PDPData &lhs, const PDPData &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Vector3 FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vector3TypeTable();
  }
  Vector3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vector3(double _x, double _y, double _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  double x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  void mutate_x(double _x) {
    ::flatbuffers::WriteScalar(&x_, _x);
  }
  double y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  void mutate_y(double _y) {
    ::flatbuffers::WriteScalar(&y_, _y);
  }
  double z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  void mutate_z(double _z) {
    ::flatbuffers::WriteScalar(&z_, _z);
  }
};
FLATBUFFERS_STRUCT_END(Vector3, 24);

inline bool operator==(const Vector3 &lhs, const Vector3 &rhs) {
  return
      (lhs.x() == rhs.x()) &&
      (lhs.y() == rhs.y()) &&
      (lhs.z() == rhs.z());
}

inline bool operator!=(const Vector3 &lhs, const Vector3 &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Vector4 FLATBUFFERS_FINAL_CLASS {
 private:
  double w_;
  double x_;
  double y_;
  double z_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vector4TypeTable();
  }
  Vector4()
      : w_(0),
        x_(0),
        y_(0),
        z_(0) {
  }
  Vector4(double _w, double _x, double _y, double _z)
      : w_(::flatbuffers::EndianScalar(_w)),
        x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  double w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
  void mutate_w(double _w) {
    ::flatbuffers::WriteScalar(&w_, _w);
  }
  double x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  void mutate_x(double _x) {
    ::flatbuffers::WriteScalar(&x_, _x);
  }
  double y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  void mutate_y(double _y) {
    ::flatbuffers::WriteScalar(&y_, _y);
  }
  double z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  void mutate_z(double _z) {
    ::flatbuffers::WriteScalar(&z_, _z);
  }
};
FLATBUFFERS_STRUCT_END(Vector4, 32);

inline bool operator==(const Vector4 &lhs, const Vector4 &rhs) {
  return
      (lhs.w() == rhs.w()) &&
      (lhs.x() == rhs.x()) &&
      (lhs.y() == rhs.y()) &&
      (lhs.z() == rhs.z());
}

inline bool operator!=(const Vector4 &lhs, const Vector4 &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SystemData FLATBUFFERS_FINAL_CLASS {
 private:
  double battery_voltage_;
  uint8_t watchdog_active_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;
  double can_bandwidth_[5];
  int64_t io_frequency_;
  int64_t team_number_;
  int64_t epoch_time_;
  double cpu_percent_;
  double cpu_temp_;
  int64_t memory_usage_bytes_;
  int64_t memory_total_bytes_;
  double memory_percent_;
  int64_t storage_usage_bytes_;
  int64_t storage_total_bytes_;
  double storage_percent_;
  org::littletonrobotics::conduit::schema::Vector3 imu_accel_raw_;
  org::littletonrobotics::conduit::schema::Vector3 imu_gyro_rates_;
  org::littletonrobotics::conduit::schema::Vector3 imu_gyro_euler_;
  org::littletonrobotics::conduit::schema::Vector4 imu_gyro_quaternion_;
  double imu_gyro_yaw_flat_;
  double imu_gyro_yaw_landscape_;
  double imu_gyro_yaw_portrait_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SystemDataTypeTable();
  }
  SystemData()
      : battery_voltage_(0),
        watchdog_active_(0),
        padding0__(0),
        padding1__(0),
        padding2__(0),
        can_bandwidth_(),
        io_frequency_(0),
        team_number_(0),
        epoch_time_(0),
        cpu_percent_(0),
        cpu_temp_(0),
        memory_usage_bytes_(0),
        memory_total_bytes_(0),
        memory_percent_(0),
        storage_usage_bytes_(0),
        storage_total_bytes_(0),
        storage_percent_(0),
        imu_accel_raw_(),
        imu_gyro_rates_(),
        imu_gyro_euler_(),
        imu_gyro_quaternion_(),
        imu_gyro_yaw_flat_(0),
        imu_gyro_yaw_landscape_(0),
        imu_gyro_yaw_portrait_(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  SystemData(double _battery_voltage, bool _watchdog_active, int64_t _io_frequency, int64_t _team_number, int64_t _epoch_time, double _cpu_percent, double _cpu_temp, int64_t _memory_usage_bytes, int64_t _memory_total_bytes, double _memory_percent, int64_t _storage_usage_bytes, int64_t _storage_total_bytes, double _storage_percent, const org::littletonrobotics::conduit::schema::Vector3 &_imu_accel_raw, const org::littletonrobotics::conduit::schema::Vector3 &_imu_gyro_rates, const org::littletonrobotics::conduit::schema::Vector3 &_imu_gyro_euler, const org::littletonrobotics::conduit::schema::Vector4 &_imu_gyro_quaternion, double _imu_gyro_yaw_flat, double _imu_gyro_yaw_landscape, double _imu_gyro_yaw_portrait)
      : battery_voltage_(::flatbuffers::EndianScalar(_battery_voltage)),
        watchdog_active_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_watchdog_active))),
        padding0__(0),
        padding1__(0),
        padding2__(0),
        can_bandwidth_(),
        io_frequency_(::flatbuffers::EndianScalar(_io_frequency)),
        team_number_(::flatbuffers::EndianScalar(_team_number)),
        epoch_time_(::flatbuffers::EndianScalar(_epoch_time)),
        cpu_percent_(::flatbuffers::EndianScalar(_cpu_percent)),
        cpu_temp_(::flatbuffers::EndianScalar(_cpu_temp)),
        memory_usage_bytes_(::flatbuffers::EndianScalar(_memory_usage_bytes)),
        memory_total_bytes_(::flatbuffers::EndianScalar(_memory_total_bytes)),
        memory_percent_(::flatbuffers::EndianScalar(_memory_percent)),
        storage_usage_bytes_(::flatbuffers::EndianScalar(_storage_usage_bytes)),
        storage_total_bytes_(::flatbuffers::EndianScalar(_storage_total_bytes)),
        storage_percent_(::flatbuffers::EndianScalar(_storage_percent)),
        imu_accel_raw_(_imu_accel_raw),
        imu_gyro_rates_(_imu_gyro_rates),
        imu_gyro_euler_(_imu_gyro_euler),
        imu_gyro_quaternion_(_imu_gyro_quaternion),
        imu_gyro_yaw_flat_(::flatbuffers::EndianScalar(_imu_gyro_yaw_flat)),
        imu_gyro_yaw_landscape_(::flatbuffers::EndianScalar(_imu_gyro_yaw_landscape)),
        imu_gyro_yaw_portrait_(::flatbuffers::EndianScalar(_imu_gyro_yaw_portrait)) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  SystemData(double _battery_voltage, bool _watchdog_active, ::flatbuffers::span<const double, 5> _can_bandwidth, int64_t _io_frequency, int64_t _team_number, int64_t _epoch_time, double _cpu_percent, double _cpu_temp, int64_t _memory_usage_bytes, int64_t _memory_total_bytes, double _memory_percent, int64_t _storage_usage_bytes, int64_t _storage_total_bytes, double _storage_percent, const org::littletonrobotics::conduit::schema::Vector3 &_imu_accel_raw, const org::littletonrobotics::conduit::schema::Vector3 &_imu_gyro_rates, const org::littletonrobotics::conduit::schema::Vector3 &_imu_gyro_euler, const org::littletonrobotics::conduit::schema::Vector4 &_imu_gyro_quaternion, double _imu_gyro_yaw_flat, double _imu_gyro_yaw_landscape, double _imu_gyro_yaw_portrait)
      : battery_voltage_(::flatbuffers::EndianScalar(_battery_voltage)),
        watchdog_active_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_watchdog_active))),
        padding0__(0),
        padding1__(0),
        padding2__(0),
        io_frequency_(::flatbuffers::EndianScalar(_io_frequency)),
        team_number_(::flatbuffers::EndianScalar(_team_number)),
        epoch_time_(::flatbuffers::EndianScalar(_epoch_time)),
        cpu_percent_(::flatbuffers::EndianScalar(_cpu_percent)),
        cpu_temp_(::flatbuffers::EndianScalar(_cpu_temp)),
        memory_usage_bytes_(::flatbuffers::EndianScalar(_memory_usage_bytes)),
        memory_total_bytes_(::flatbuffers::EndianScalar(_memory_total_bytes)),
        memory_percent_(::flatbuffers::EndianScalar(_memory_percent)),
        storage_usage_bytes_(::flatbuffers::EndianScalar(_storage_usage_bytes)),
        storage_total_bytes_(::flatbuffers::EndianScalar(_storage_total_bytes)),
        storage_percent_(::flatbuffers::EndianScalar(_storage_percent)),
        imu_accel_raw_(_imu_accel_raw),
        imu_gyro_rates_(_imu_gyro_rates),
        imu_gyro_euler_(_imu_gyro_euler),
        imu_gyro_quaternion_(_imu_gyro_quaternion),
        imu_gyro_yaw_flat_(::flatbuffers::EndianScalar(_imu_gyro_yaw_flat)),
        imu_gyro_yaw_landscape_(::flatbuffers::EndianScalar(_imu_gyro_yaw_landscape)),
        imu_gyro_yaw_portrait_(::flatbuffers::EndianScalar(_imu_gyro_yaw_portrait)) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    ::flatbuffers::CastToArray(can_bandwidth_).CopyFromSpan(_can_bandwidth);
  }
  double battery_voltage() const {
    return ::flatbuffers::EndianScalar(battery_voltage_);
  }
  void mutate_battery_voltage(double _battery_voltage) {
    ::flatbuffers::WriteScalar(&battery_voltage_, _battery_voltage);
  }
  bool watchdog_active() const {
    return ::flatbuffers::EndianScalar(watchdog_active_) != 0;
  }
  void mutate_watchdog_active(bool _watchdog_active) {
    ::flatbuffers::WriteScalar(&watchdog_active_, static_cast<uint8_t>(_watchdog_active));
  }
  const ::flatbuffers::Array<double, 5> *can_bandwidth() const {
    return &::flatbuffers::CastToArray(can_bandwidth_);
  }
  ::flatbuffers::Array<double, 5> *mutable_can_bandwidth() {
    return &::flatbuffers::CastToArray(can_bandwidth_);
  }
  int64_t io_frequency() const {
    return ::flatbuffers::EndianScalar(io_frequency_);
  }
  void mutate_io_frequency(int64_t _io_frequency) {
    ::flatbuffers::WriteScalar(&io_frequency_, _io_frequency);
  }
  int64_t team_number() const {
    return ::flatbuffers::EndianScalar(team_number_);
  }
  void mutate_team_number(int64_t _team_number) {
    ::flatbuffers::WriteScalar(&team_number_, _team_number);
  }
  int64_t epoch_time() const {
    return ::flatbuffers::EndianScalar(epoch_time_);
  }
  void mutate_epoch_time(int64_t _epoch_time) {
    ::flatbuffers::WriteScalar(&epoch_time_, _epoch_time);
  }
  double cpu_percent() const {
    return ::flatbuffers::EndianScalar(cpu_percent_);
  }
  void mutate_cpu_percent(double _cpu_percent) {
    ::flatbuffers::WriteScalar(&cpu_percent_, _cpu_percent);
  }
  double cpu_temp() const {
    return ::flatbuffers::EndianScalar(cpu_temp_);
  }
  void mutate_cpu_temp(double _cpu_temp) {
    ::flatbuffers::WriteScalar(&cpu_temp_, _cpu_temp);
  }
  int64_t memory_usage_bytes() const {
    return ::flatbuffers::EndianScalar(memory_usage_bytes_);
  }
  void mutate_memory_usage_bytes(int64_t _memory_usage_bytes) {
    ::flatbuffers::WriteScalar(&memory_usage_bytes_, _memory_usage_bytes);
  }
  int64_t memory_total_bytes() const {
    return ::flatbuffers::EndianScalar(memory_total_bytes_);
  }
  void mutate_memory_total_bytes(int64_t _memory_total_bytes) {
    ::flatbuffers::WriteScalar(&memory_total_bytes_, _memory_total_bytes);
  }
  double memory_percent() const {
    return ::flatbuffers::EndianScalar(memory_percent_);
  }
  void mutate_memory_percent(double _memory_percent) {
    ::flatbuffers::WriteScalar(&memory_percent_, _memory_percent);
  }
  int64_t storage_usage_bytes() const {
    return ::flatbuffers::EndianScalar(storage_usage_bytes_);
  }
  void mutate_storage_usage_bytes(int64_t _storage_usage_bytes) {
    ::flatbuffers::WriteScalar(&storage_usage_bytes_, _storage_usage_bytes);
  }
  int64_t storage_total_bytes() const {
    return ::flatbuffers::EndianScalar(storage_total_bytes_);
  }
  void mutate_storage_total_bytes(int64_t _storage_total_bytes) {
    ::flatbuffers::WriteScalar(&storage_total_bytes_, _storage_total_bytes);
  }
  double storage_percent() const {
    return ::flatbuffers::EndianScalar(storage_percent_);
  }
  void mutate_storage_percent(double _storage_percent) {
    ::flatbuffers::WriteScalar(&storage_percent_, _storage_percent);
  }
  const org::littletonrobotics::conduit::schema::Vector3 &imu_accel_raw() const {
    return imu_accel_raw_;
  }
  org::littletonrobotics::conduit::schema::Vector3 &mutable_imu_accel_raw() {
    return imu_accel_raw_;
  }
  const org::littletonrobotics::conduit::schema::Vector3 &imu_gyro_rates() const {
    return imu_gyro_rates_;
  }
  org::littletonrobotics::conduit::schema::Vector3 &mutable_imu_gyro_rates() {
    return imu_gyro_rates_;
  }
  const org::littletonrobotics::conduit::schema::Vector3 &imu_gyro_euler() const {
    return imu_gyro_euler_;
  }
  org::littletonrobotics::conduit::schema::Vector3 &mutable_imu_gyro_euler() {
    return imu_gyro_euler_;
  }
  const org::littletonrobotics::conduit::schema::Vector4 &imu_gyro_quaternion() const {
    return imu_gyro_quaternion_;
  }
  org::littletonrobotics::conduit::schema::Vector4 &mutable_imu_gyro_quaternion() {
    return imu_gyro_quaternion_;
  }
  double imu_gyro_yaw_flat() const {
    return ::flatbuffers::EndianScalar(imu_gyro_yaw_flat_);
  }
  void mutate_imu_gyro_yaw_flat(double _imu_gyro_yaw_flat) {
    ::flatbuffers::WriteScalar(&imu_gyro_yaw_flat_, _imu_gyro_yaw_flat);
  }
  double imu_gyro_yaw_landscape() const {
    return ::flatbuffers::EndianScalar(imu_gyro_yaw_landscape_);
  }
  void mutate_imu_gyro_yaw_landscape(double _imu_gyro_yaw_landscape) {
    ::flatbuffers::WriteScalar(&imu_gyro_yaw_landscape_, _imu_gyro_yaw_landscape);
  }
  double imu_gyro_yaw_portrait() const {
    return ::flatbuffers::EndianScalar(imu_gyro_yaw_portrait_);
  }
  void mutate_imu_gyro_yaw_portrait(double _imu_gyro_yaw_portrait) {
    ::flatbuffers::WriteScalar(&imu_gyro_yaw_portrait_, _imu_gyro_yaw_portrait);
  }
};
FLATBUFFERS_STRUCT_END(SystemData, 272);

inline bool operator==(const SystemData &lhs, const SystemData &rhs) {
  return
      (lhs.battery_voltage() == rhs.battery_voltage()) &&
      (lhs.watchdog_active() == rhs.watchdog_active()) &&
      (*lhs.can_bandwidth() == *rhs.can_bandwidth()) &&
      (lhs.io_frequency() == rhs.io_frequency()) &&
      (lhs.team_number() == rhs.team_number()) &&
      (lhs.epoch_time() == rhs.epoch_time()) &&
      (lhs.cpu_percent() == rhs.cpu_percent()) &&
      (lhs.cpu_temp() == rhs.cpu_temp()) &&
      (lhs.memory_usage_bytes() == rhs.memory_usage_bytes()) &&
      (lhs.memory_total_bytes() == rhs.memory_total_bytes()) &&
      (lhs.memory_percent() == rhs.memory_percent()) &&
      (lhs.storage_usage_bytes() == rhs.storage_usage_bytes()) &&
      (lhs.storage_total_bytes() == rhs.storage_total_bytes()) &&
      (lhs.storage_percent() == rhs.storage_percent()) &&
      (lhs.imu_accel_raw() == rhs.imu_accel_raw()) &&
      (lhs.imu_gyro_rates() == rhs.imu_gyro_rates()) &&
      (lhs.imu_gyro_euler() == rhs.imu_gyro_euler()) &&
      (lhs.imu_gyro_quaternion() == rhs.imu_gyro_quaternion()) &&
      (lhs.imu_gyro_yaw_flat() == rhs.imu_gyro_yaw_flat()) &&
      (lhs.imu_gyro_yaw_landscape() == rhs.imu_gyro_yaw_landscape()) &&
      (lhs.imu_gyro_yaw_portrait() == rhs.imu_gyro_yaw_portrait());
}

inline bool operator!=(const SystemData &lhs, const SystemData &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) CoreInputs FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t timestamp_;
  org::littletonrobotics::conduit::schema::DSData ds_;
  org::littletonrobotics::conduit::schema::PDPData pdp_;
  org::littletonrobotics::conduit::schema::SystemData sys_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CoreInputsTypeTable();
  }
  CoreInputs()
      : timestamp_(0),
        ds_(),
        pdp_(),
        sys_() {
  }
  CoreInputs(int64_t _timestamp, const org::littletonrobotics::conduit::schema::DSData &_ds, const org::littletonrobotics::conduit::schema::PDPData &_pdp, const org::littletonrobotics::conduit::schema::SystemData &_sys)
      : timestamp_(::flatbuffers::EndianScalar(_timestamp)),
        ds_(_ds),
        pdp_(_pdp),
        sys_(_sys) {
  }
  int64_t timestamp() const {
    return ::flatbuffers::EndianScalar(timestamp_);
  }
  void mutate_timestamp(int64_t _timestamp) {
    ::flatbuffers::WriteScalar(&timestamp_, _timestamp);
  }
  const org::littletonrobotics::conduit::schema::DSData &ds() const {
    return ds_;
  }
  org::littletonrobotics::conduit::schema::DSData &mutable_ds() {
    return ds_;
  }
  const org::littletonrobotics::conduit::schema::PDPData &pdp() const {
    return pdp_;
  }
  org::littletonrobotics::conduit::schema::PDPData &mutable_pdp() {
    return pdp_;
  }
  const org::littletonrobotics::conduit::schema::SystemData &sys() const {
    return sys_;
  }
  org::littletonrobotics::conduit::schema::SystemData &mutable_sys() {
    return sys_;
  }
};
FLATBUFFERS_STRUCT_END(CoreInputs, 2736);

inline bool operator==(const CoreInputs &lhs, const CoreInputs &rhs) {
  return
      (lhs.timestamp() == rhs.timestamp()) &&
      (lhs.ds() == rhs.ds()) &&
      (lhs.pdp() == rhs.pdp()) &&
      (lhs.sys() == rhs.sys());
}

inline bool operator!=(const CoreInputs &lhs, const CoreInputs &rhs) {
    return !(lhs == rhs);
}


inline const ::flatbuffers::TypeTable *JoystickTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_SHORT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_SHORT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const int16_t array_sizes[] = { 256, 12, 12, 8,  };
  static const int64_t values[] = { 0, 256, 258, 260, 272, 320, 324, 328, 330, 338, 340 };
  static const char * const names[] = {
    "name",
    "type",
    "axis_count",
    "axis_types",
    "axis_values",
    "button_count",
    "buttons",
    "pov_count",
    "pov_values",
    "is_gamepad"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 10, type_codes, nullptr, array_sizes, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DSDataTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_USHORT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_USHORT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    org::littletonrobotics::conduit::schema::JoystickTypeTable
  };
  static const int16_t array_sizes[] = { 64, 64, 6,  };
  static const int64_t values[] = { 0, 4, 68, 70, 134, 136, 140, 144, 152, 160, 2200 };
  static const char * const names[] = {
    "alliance_station",
    "event_name",
    "game_specific_message_size",
    "game_specific_message",
    "match_number",
    "replay_number",
    "match_type",
    "control_word",
    "match_time",
    "joysticks"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 10, type_codes, type_refs, array_sizes, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PDPDataTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 1, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const int16_t array_sizes[] = { 24,  };
  static const int64_t values[] = { 0, 4, 8, 12, 16, 20, 24, 32, 40, 232, 240, 248, 256 };
  static const char * const names[] = {
    "handle",
    "channel_count",
    "type",
    "module_id",
    "faults",
    "sticky_faults",
    "temperature",
    "voltage",
    "channel_current",
    "total_current",
    "total_power",
    "total_energy"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 12, type_codes, nullptr, array_sizes, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *Vector3TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const int64_t values[] = { 0, 8, 16, 24 };
  static const char * const names[] = {
    "x",
    "y",
    "z"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 3, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *Vector4TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const int64_t values[] = { 0, 8, 16, 24, 32 };
  static const char * const names[] = {
    "w",
    "x",
    "y",
    "z"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 4, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SystemDataTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 1, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    org::littletonrobotics::conduit::schema::Vector3TypeTable,
    org::littletonrobotics::conduit::schema::Vector4TypeTable
  };
  static const int16_t array_sizes[] = { 5,  };
  static const int64_t values[] = { 0, 8, 16, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128, 136, 144, 168, 192, 216, 248, 256, 264, 272 };
  static const char * const names[] = {
    "battery_voltage",
    "watchdog_active",
    "can_bandwidth",
    "io_frequency",
    "team_number",
    "epoch_time",
    "cpu_percent",
    "cpu_temp",
    "memory_usage_bytes",
    "memory_total_bytes",
    "memory_percent",
    "storage_usage_bytes",
    "storage_total_bytes",
    "storage_percent",
    "imu_accel_raw",
    "imu_gyro_rates",
    "imu_gyro_euler",
    "imu_gyro_quaternion",
    "imu_gyro_yaw_flat",
    "imu_gyro_yaw_landscape",
    "imu_gyro_yaw_portrait"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 21, type_codes, type_refs, array_sizes, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CoreInputsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    org::littletonrobotics::conduit::schema::DSDataTypeTable,
    org::littletonrobotics::conduit::schema::PDPDataTypeTable,
    org::littletonrobotics::conduit::schema::SystemDataTypeTable
  };
  static const int64_t values[] = { 0, 8, 2208, 2464, 2736 };
  static const char * const names[] = {
    "timestamp",
    "ds",
    "pdp",
    "sys"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 4, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

}  // namespace schema
}  // namespace conduit
}  // namespace littletonrobotics
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_CONDUITSCHEMA_ORG_LITTLETONROBOTICS_CONDUIT_SCHEMA_H_
