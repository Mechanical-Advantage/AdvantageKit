// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CONDUITSCHEMA_ORG_LITTLETONROBOTICS_CONDUIT_SCHEMA_H_
#define FLATBUFFERS_GENERATED_CONDUITSCHEMA_ORG_LITTLETONROBOTICS_CONDUIT_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace org {
namespace littletonrobotics {
namespace conduit {
namespace schema {

struct Joystick;

struct DSData;

struct PDPData;

struct CANStatus;

struct SystemData;

struct CoreInputs;

inline const ::flatbuffers::TypeTable *JoystickTypeTable();

inline const ::flatbuffers::TypeTable *DSDataTypeTable();

inline const ::flatbuffers::TypeTable *PDPDataTypeTable();

inline const ::flatbuffers::TypeTable *CANStatusTypeTable();

inline const ::flatbuffers::TypeTable *SystemDataTypeTable();

inline const ::flatbuffers::TypeTable *CoreInputsTypeTable();

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Joystick FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t name_[256];
  uint8_t type_;
  int8_t padding0__;
  int16_t axis_count_;
  uint8_t axis_types_[12];
  float axis_values_[12];
  uint8_t button_count_;
  int8_t padding1__;  int16_t padding2__;
  int32_t buttons_;
  int16_t pov_count_;
  int16_t pov_values_[12];
  uint8_t is_xbox_;
  int8_t padding3__;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return JoystickTypeTable();
  }
  Joystick()
      : name_(),
        type_(0),
        padding0__(0),
        axis_count_(0),
        axis_types_(),
        axis_values_(),
        button_count_(0),
        padding1__(0),
        padding2__(0),
        buttons_(0),
        pov_count_(0),
        pov_values_(),
        is_xbox_(0),
        padding3__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
  }
  Joystick(uint8_t _type, int16_t _axis_count, uint8_t _button_count, int32_t _buttons, int16_t _pov_count, bool _is_xbox)
      : name_(),
        type_(::flatbuffers::EndianScalar(_type)),
        padding0__(0),
        axis_count_(::flatbuffers::EndianScalar(_axis_count)),
        axis_types_(),
        axis_values_(),
        button_count_(::flatbuffers::EndianScalar(_button_count)),
        padding1__(0),
        padding2__(0),
        buttons_(::flatbuffers::EndianScalar(_buttons)),
        pov_count_(::flatbuffers::EndianScalar(_pov_count)),
        pov_values_(),
        is_xbox_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_is_xbox))),
        padding3__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
  }
  Joystick(::flatbuffers::span<const uint8_t, 256> _name, uint8_t _type, int16_t _axis_count, ::flatbuffers::span<const uint8_t, 12> _axis_types, ::flatbuffers::span<const float, 12> _axis_values, uint8_t _button_count, int32_t _buttons, int16_t _pov_count, ::flatbuffers::span<const int16_t, 12> _pov_values, bool _is_xbox)
      : type_(::flatbuffers::EndianScalar(_type)),
        padding0__(0),
        axis_count_(::flatbuffers::EndianScalar(_axis_count)),
        button_count_(::flatbuffers::EndianScalar(_button_count)),
        padding1__(0),
        padding2__(0),
        buttons_(::flatbuffers::EndianScalar(_buttons)),
        pov_count_(::flatbuffers::EndianScalar(_pov_count)),
        is_xbox_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_is_xbox))),
        padding3__(0) {
    ::flatbuffers::CastToArray(name_).CopyFromSpan(_name);
    (void)padding0__;
    ::flatbuffers::CastToArray(axis_types_).CopyFromSpan(_axis_types);
    ::flatbuffers::CastToArray(axis_values_).CopyFromSpan(_axis_values);
    (void)padding1__;
    (void)padding2__;
    ::flatbuffers::CastToArray(pov_values_).CopyFromSpan(_pov_values);
    (void)padding3__;
  }
  const ::flatbuffers::Array<uint8_t, 256> *name() const {
    return &::flatbuffers::CastToArray(name_);
  }
  ::flatbuffers::Array<uint8_t, 256> *mutable_name() {
    return &::flatbuffers::CastToArray(name_);
  }
  uint8_t type() const {
    return ::flatbuffers::EndianScalar(type_);
  }
  void mutate_type(uint8_t _type) {
    ::flatbuffers::WriteScalar(&type_, _type);
  }
  int16_t axis_count() const {
    return ::flatbuffers::EndianScalar(axis_count_);
  }
  void mutate_axis_count(int16_t _axis_count) {
    ::flatbuffers::WriteScalar(&axis_count_, _axis_count);
  }
  const ::flatbuffers::Array<uint8_t, 12> *axis_types() const {
    return &::flatbuffers::CastToArray(axis_types_);
  }
  ::flatbuffers::Array<uint8_t, 12> *mutable_axis_types() {
    return &::flatbuffers::CastToArray(axis_types_);
  }
  const ::flatbuffers::Array<float, 12> *axis_values() const {
    return &::flatbuffers::CastToArray(axis_values_);
  }
  ::flatbuffers::Array<float, 12> *mutable_axis_values() {
    return &::flatbuffers::CastToArray(axis_values_);
  }
  uint8_t button_count() const {
    return ::flatbuffers::EndianScalar(button_count_);
  }
  void mutate_button_count(uint8_t _button_count) {
    ::flatbuffers::WriteScalar(&button_count_, _button_count);
  }
  int32_t buttons() const {
    return ::flatbuffers::EndianScalar(buttons_);
  }
  void mutate_buttons(int32_t _buttons) {
    ::flatbuffers::WriteScalar(&buttons_, _buttons);
  }
  int16_t pov_count() const {
    return ::flatbuffers::EndianScalar(pov_count_);
  }
  void mutate_pov_count(int16_t _pov_count) {
    ::flatbuffers::WriteScalar(&pov_count_, _pov_count);
  }
  const ::flatbuffers::Array<int16_t, 12> *pov_values() const {
    return &::flatbuffers::CastToArray(pov_values_);
  }
  ::flatbuffers::Array<int16_t, 12> *mutable_pov_values() {
    return &::flatbuffers::CastToArray(pov_values_);
  }
  bool is_xbox() const {
    return ::flatbuffers::EndianScalar(is_xbox_) != 0;
  }
  void mutate_is_xbox(bool _is_xbox) {
    ::flatbuffers::WriteScalar(&is_xbox_, static_cast<uint8_t>(_is_xbox));
  }
};
FLATBUFFERS_STRUCT_END(Joystick, 356);

inline bool operator==(const Joystick &lhs, const Joystick &rhs) {
  return
      (*lhs.name() == *rhs.name()) &&
      (lhs.type() == rhs.type()) &&
      (lhs.axis_count() == rhs.axis_count()) &&
      (*lhs.axis_types() == *rhs.axis_types()) &&
      (*lhs.axis_values() == *rhs.axis_values()) &&
      (lhs.button_count() == rhs.button_count()) &&
      (lhs.buttons() == rhs.buttons()) &&
      (lhs.pov_count() == rhs.pov_count()) &&
      (*lhs.pov_values() == *rhs.pov_values()) &&
      (lhs.is_xbox() == rhs.is_xbox());
}

inline bool operator!=(const Joystick &lhs, const Joystick &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DSData FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t alliance_station_;
  uint8_t event_name_[64];
  uint16_t game_specific_message_size_;
  uint8_t game_specific_message_[64];
  uint16_t match_number_;
  uint8_t replay_number_;
  int8_t padding0__;  int16_t padding1__;
  int32_t match_type_;
  int32_t control_word_;
  int32_t padding2__;
  double match_time_;
  org::littletonrobotics::conduit::schema::Joystick joysticks_[6];

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DSDataTypeTable();
  }
  DSData()
      : alliance_station_(0),
        event_name_(),
        game_specific_message_size_(0),
        game_specific_message_(),
        match_number_(0),
        replay_number_(0),
        padding0__(0),
        padding1__(0),
        match_type_(0),
        control_word_(0),
        padding2__(0),
        match_time_(0),
        joysticks_() {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  DSData(int32_t _alliance_station, uint16_t _game_specific_message_size, uint16_t _match_number, uint8_t _replay_number, int32_t _match_type, int32_t _control_word, double _match_time)
      : alliance_station_(::flatbuffers::EndianScalar(_alliance_station)),
        event_name_(),
        game_specific_message_size_(::flatbuffers::EndianScalar(_game_specific_message_size)),
        game_specific_message_(),
        match_number_(::flatbuffers::EndianScalar(_match_number)),
        replay_number_(::flatbuffers::EndianScalar(_replay_number)),
        padding0__(0),
        padding1__(0),
        match_type_(::flatbuffers::EndianScalar(_match_type)),
        control_word_(::flatbuffers::EndianScalar(_control_word)),
        padding2__(0),
        match_time_(::flatbuffers::EndianScalar(_match_time)),
        joysticks_() {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  DSData(int32_t _alliance_station, ::flatbuffers::span<const uint8_t, 64> _event_name, uint16_t _game_specific_message_size, ::flatbuffers::span<const uint8_t, 64> _game_specific_message, uint16_t _match_number, uint8_t _replay_number, int32_t _match_type, int32_t _control_word, double _match_time, ::flatbuffers::span<const org::littletonrobotics::conduit::schema::Joystick, 6> _joysticks)
      : alliance_station_(::flatbuffers::EndianScalar(_alliance_station)),
        game_specific_message_size_(::flatbuffers::EndianScalar(_game_specific_message_size)),
        match_number_(::flatbuffers::EndianScalar(_match_number)),
        replay_number_(::flatbuffers::EndianScalar(_replay_number)),
        padding0__(0),
        padding1__(0),
        match_type_(::flatbuffers::EndianScalar(_match_type)),
        control_word_(::flatbuffers::EndianScalar(_control_word)),
        padding2__(0),
        match_time_(::flatbuffers::EndianScalar(_match_time)) {
    ::flatbuffers::CastToArray(event_name_).CopyFromSpan(_event_name);
    ::flatbuffers::CastToArray(game_specific_message_).CopyFromSpan(_game_specific_message);
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    ::flatbuffers::CastToArray(joysticks_).CopyFromSpan(_joysticks);
  }
  int32_t alliance_station() const {
    return ::flatbuffers::EndianScalar(alliance_station_);
  }
  void mutate_alliance_station(int32_t _alliance_station) {
    ::flatbuffers::WriteScalar(&alliance_station_, _alliance_station);
  }
  const ::flatbuffers::Array<uint8_t, 64> *event_name() const {
    return &::flatbuffers::CastToArray(event_name_);
  }
  ::flatbuffers::Array<uint8_t, 64> *mutable_event_name() {
    return &::flatbuffers::CastToArray(event_name_);
  }
  uint16_t game_specific_message_size() const {
    return ::flatbuffers::EndianScalar(game_specific_message_size_);
  }
  void mutate_game_specific_message_size(uint16_t _game_specific_message_size) {
    ::flatbuffers::WriteScalar(&game_specific_message_size_, _game_specific_message_size);
  }
  const ::flatbuffers::Array<uint8_t, 64> *game_specific_message() const {
    return &::flatbuffers::CastToArray(game_specific_message_);
  }
  ::flatbuffers::Array<uint8_t, 64> *mutable_game_specific_message() {
    return &::flatbuffers::CastToArray(game_specific_message_);
  }
  uint16_t match_number() const {
    return ::flatbuffers::EndianScalar(match_number_);
  }
  void mutate_match_number(uint16_t _match_number) {
    ::flatbuffers::WriteScalar(&match_number_, _match_number);
  }
  uint8_t replay_number() const {
    return ::flatbuffers::EndianScalar(replay_number_);
  }
  void mutate_replay_number(uint8_t _replay_number) {
    ::flatbuffers::WriteScalar(&replay_number_, _replay_number);
  }
  int32_t match_type() const {
    return ::flatbuffers::EndianScalar(match_type_);
  }
  void mutate_match_type(int32_t _match_type) {
    ::flatbuffers::WriteScalar(&match_type_, _match_type);
  }
  int32_t control_word() const {
    return ::flatbuffers::EndianScalar(control_word_);
  }
  void mutate_control_word(int32_t _control_word) {
    ::flatbuffers::WriteScalar(&control_word_, _control_word);
  }
  double match_time() const {
    return ::flatbuffers::EndianScalar(match_time_);
  }
  void mutate_match_time(double _match_time) {
    ::flatbuffers::WriteScalar(&match_time_, _match_time);
  }
  const ::flatbuffers::Array<org::littletonrobotics::conduit::schema::Joystick, 6> *joysticks() const {
    return &::flatbuffers::CastToArray(joysticks_);
  }
  ::flatbuffers::Array<org::littletonrobotics::conduit::schema::Joystick, 6> *mutable_joysticks() {
    return &::flatbuffers::CastToArray(joysticks_);
  }
};
FLATBUFFERS_STRUCT_END(DSData, 2296);

inline bool operator==(const DSData &lhs, const DSData &rhs) {
  return
      (lhs.alliance_station() == rhs.alliance_station()) &&
      (*lhs.event_name() == *rhs.event_name()) &&
      (lhs.game_specific_message_size() == rhs.game_specific_message_size()) &&
      (*lhs.game_specific_message() == *rhs.game_specific_message()) &&
      (lhs.match_number() == rhs.match_number()) &&
      (lhs.replay_number() == rhs.replay_number()) &&
      (lhs.match_type() == rhs.match_type()) &&
      (lhs.control_word() == rhs.control_word()) &&
      (lhs.match_time() == rhs.match_time()) &&
      (*lhs.joysticks() == *rhs.joysticks());
}

inline bool operator!=(const DSData &lhs, const DSData &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) PDPData FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t handle_;
  int32_t channel_count_;
  int32_t type_;
  int32_t module_id_;
  uint32_t faults_;
  uint32_t sticky_faults_;
  double temperature_;
  double voltage_;
  double channel_current_[24];
  double total_current_;
  double total_power_;
  double total_energy_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PDPDataTypeTable();
  }
  PDPData()
      : handle_(0),
        channel_count_(0),
        type_(0),
        module_id_(0),
        faults_(0),
        sticky_faults_(0),
        temperature_(0),
        voltage_(0),
        channel_current_(),
        total_current_(0),
        total_power_(0),
        total_energy_(0) {
  }
  PDPData(int32_t _handle, int32_t _channel_count, int32_t _type, int32_t _module_id, uint32_t _faults, uint32_t _sticky_faults, double _temperature, double _voltage, double _total_current, double _total_power, double _total_energy)
      : handle_(::flatbuffers::EndianScalar(_handle)),
        channel_count_(::flatbuffers::EndianScalar(_channel_count)),
        type_(::flatbuffers::EndianScalar(_type)),
        module_id_(::flatbuffers::EndianScalar(_module_id)),
        faults_(::flatbuffers::EndianScalar(_faults)),
        sticky_faults_(::flatbuffers::EndianScalar(_sticky_faults)),
        temperature_(::flatbuffers::EndianScalar(_temperature)),
        voltage_(::flatbuffers::EndianScalar(_voltage)),
        channel_current_(),
        total_current_(::flatbuffers::EndianScalar(_total_current)),
        total_power_(::flatbuffers::EndianScalar(_total_power)),
        total_energy_(::flatbuffers::EndianScalar(_total_energy)) {
  }
  PDPData(int32_t _handle, int32_t _channel_count, int32_t _type, int32_t _module_id, uint32_t _faults, uint32_t _sticky_faults, double _temperature, double _voltage, ::flatbuffers::span<const double, 24> _channel_current, double _total_current, double _total_power, double _total_energy)
      : handle_(::flatbuffers::EndianScalar(_handle)),
        channel_count_(::flatbuffers::EndianScalar(_channel_count)),
        type_(::flatbuffers::EndianScalar(_type)),
        module_id_(::flatbuffers::EndianScalar(_module_id)),
        faults_(::flatbuffers::EndianScalar(_faults)),
        sticky_faults_(::flatbuffers::EndianScalar(_sticky_faults)),
        temperature_(::flatbuffers::EndianScalar(_temperature)),
        voltage_(::flatbuffers::EndianScalar(_voltage)),
        total_current_(::flatbuffers::EndianScalar(_total_current)),
        total_power_(::flatbuffers::EndianScalar(_total_power)),
        total_energy_(::flatbuffers::EndianScalar(_total_energy)) {
    ::flatbuffers::CastToArray(channel_current_).CopyFromSpan(_channel_current);
  }
  int32_t handle() const {
    return ::flatbuffers::EndianScalar(handle_);
  }
  void mutate_handle(int32_t _handle) {
    ::flatbuffers::WriteScalar(&handle_, _handle);
  }
  int32_t channel_count() const {
    return ::flatbuffers::EndianScalar(channel_count_);
  }
  void mutate_channel_count(int32_t _channel_count) {
    ::flatbuffers::WriteScalar(&channel_count_, _channel_count);
  }
  int32_t type() const {
    return ::flatbuffers::EndianScalar(type_);
  }
  void mutate_type(int32_t _type) {
    ::flatbuffers::WriteScalar(&type_, _type);
  }
  int32_t module_id() const {
    return ::flatbuffers::EndianScalar(module_id_);
  }
  void mutate_module_id(int32_t _module_id) {
    ::flatbuffers::WriteScalar(&module_id_, _module_id);
  }
  uint32_t faults() const {
    return ::flatbuffers::EndianScalar(faults_);
  }
  void mutate_faults(uint32_t _faults) {
    ::flatbuffers::WriteScalar(&faults_, _faults);
  }
  uint32_t sticky_faults() const {
    return ::flatbuffers::EndianScalar(sticky_faults_);
  }
  void mutate_sticky_faults(uint32_t _sticky_faults) {
    ::flatbuffers::WriteScalar(&sticky_faults_, _sticky_faults);
  }
  double temperature() const {
    return ::flatbuffers::EndianScalar(temperature_);
  }
  void mutate_temperature(double _temperature) {
    ::flatbuffers::WriteScalar(&temperature_, _temperature);
  }
  double voltage() const {
    return ::flatbuffers::EndianScalar(voltage_);
  }
  void mutate_voltage(double _voltage) {
    ::flatbuffers::WriteScalar(&voltage_, _voltage);
  }
  const ::flatbuffers::Array<double, 24> *channel_current() const {
    return &::flatbuffers::CastToArray(channel_current_);
  }
  ::flatbuffers::Array<double, 24> *mutable_channel_current() {
    return &::flatbuffers::CastToArray(channel_current_);
  }
  double total_current() const {
    return ::flatbuffers::EndianScalar(total_current_);
  }
  void mutate_total_current(double _total_current) {
    ::flatbuffers::WriteScalar(&total_current_, _total_current);
  }
  double total_power() const {
    return ::flatbuffers::EndianScalar(total_power_);
  }
  void mutate_total_power(double _total_power) {
    ::flatbuffers::WriteScalar(&total_power_, _total_power);
  }
  double total_energy() const {
    return ::flatbuffers::EndianScalar(total_energy_);
  }
  void mutate_total_energy(double _total_energy) {
    ::flatbuffers::WriteScalar(&total_energy_, _total_energy);
  }
};
FLATBUFFERS_STRUCT_END(PDPData, 256);

inline bool operator==(const PDPData &lhs, const PDPData &rhs) {
  return
      (lhs.handle() == rhs.handle()) &&
      (lhs.channel_count() == rhs.channel_count()) &&
      (lhs.type() == rhs.type()) &&
      (lhs.module_id() == rhs.module_id()) &&
      (lhs.faults() == rhs.faults()) &&
      (lhs.sticky_faults() == rhs.sticky_faults()) &&
      (lhs.temperature() == rhs.temperature()) &&
      (lhs.voltage() == rhs.voltage()) &&
      (*lhs.channel_current() == *rhs.channel_current()) &&
      (lhs.total_current() == rhs.total_current()) &&
      (lhs.total_power() == rhs.total_power()) &&
      (lhs.total_energy() == rhs.total_energy());
}

inline bool operator!=(const PDPData &lhs, const PDPData &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CANStatus FLATBUFFERS_FINAL_CLASS {
 private:
  float percent_bus_utilization_;
  uint32_t bus_off_count_;
  uint32_t tx_full_count_;
  uint32_t receive_error_count_;
  uint32_t transmit_error_count_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CANStatusTypeTable();
  }
  CANStatus()
      : percent_bus_utilization_(0),
        bus_off_count_(0),
        tx_full_count_(0),
        receive_error_count_(0),
        transmit_error_count_(0) {
  }
  CANStatus(float _percent_bus_utilization, uint32_t _bus_off_count, uint32_t _tx_full_count, uint32_t _receive_error_count, uint32_t _transmit_error_count)
      : percent_bus_utilization_(::flatbuffers::EndianScalar(_percent_bus_utilization)),
        bus_off_count_(::flatbuffers::EndianScalar(_bus_off_count)),
        tx_full_count_(::flatbuffers::EndianScalar(_tx_full_count)),
        receive_error_count_(::flatbuffers::EndianScalar(_receive_error_count)),
        transmit_error_count_(::flatbuffers::EndianScalar(_transmit_error_count)) {
  }
  float percent_bus_utilization() const {
    return ::flatbuffers::EndianScalar(percent_bus_utilization_);
  }
  void mutate_percent_bus_utilization(float _percent_bus_utilization) {
    ::flatbuffers::WriteScalar(&percent_bus_utilization_, _percent_bus_utilization);
  }
  uint32_t bus_off_count() const {
    return ::flatbuffers::EndianScalar(bus_off_count_);
  }
  void mutate_bus_off_count(uint32_t _bus_off_count) {
    ::flatbuffers::WriteScalar(&bus_off_count_, _bus_off_count);
  }
  uint32_t tx_full_count() const {
    return ::flatbuffers::EndianScalar(tx_full_count_);
  }
  void mutate_tx_full_count(uint32_t _tx_full_count) {
    ::flatbuffers::WriteScalar(&tx_full_count_, _tx_full_count);
  }
  uint32_t receive_error_count() const {
    return ::flatbuffers::EndianScalar(receive_error_count_);
  }
  void mutate_receive_error_count(uint32_t _receive_error_count) {
    ::flatbuffers::WriteScalar(&receive_error_count_, _receive_error_count);
  }
  uint32_t transmit_error_count() const {
    return ::flatbuffers::EndianScalar(transmit_error_count_);
  }
  void mutate_transmit_error_count(uint32_t _transmit_error_count) {
    ::flatbuffers::WriteScalar(&transmit_error_count_, _transmit_error_count);
  }
};
FLATBUFFERS_STRUCT_END(CANStatus, 20);

inline bool operator==(const CANStatus &lhs, const CANStatus &rhs) {
  return
      (lhs.percent_bus_utilization() == rhs.percent_bus_utilization()) &&
      (lhs.bus_off_count() == rhs.bus_off_count()) &&
      (lhs.tx_full_count() == rhs.tx_full_count()) &&
      (lhs.receive_error_count() == rhs.receive_error_count()) &&
      (lhs.transmit_error_count() == rhs.transmit_error_count());
}

inline bool operator!=(const CANStatus &lhs, const CANStatus &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SystemData FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t fpga_version_;
  int32_t fpga_revision_;
  uint16_t serial_number_size_;
  uint8_t serial_number_[8];
  uint16_t comments_size_;
  uint8_t comments_[64];
  int32_t team_number_;
  int32_t fpga_button_;
  int32_t system_active_;
  int32_t browned_out_;
  int32_t comms_disable_count_;
  int32_t rsl_state_;
  int32_t system_time_valid_;
  double voltage_vin_;
  double current_vin_;
  double user_voltage_3v3_;
  double user_current_3v3_;
  int32_t user_active_3v3_;
  int32_t user_current_faults_3v3_;
  double user_voltage_5v_;
  double user_current_5v_;
  int32_t user_active_5v_;
  int32_t user_current_faults_5v_;
  double user_voltage_6v_;
  double user_current_6v_;
  int32_t user_active_6v_;
  int32_t user_current_faults_6v_;
  double brownout_voltage_;
  double cpu_temp_;
  org::littletonrobotics::conduit::schema::CANStatus can_status_;
  int32_t padding0__;
  uint64_t epoch_time_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SystemDataTypeTable();
  }
  SystemData()
      : fpga_version_(0),
        fpga_revision_(0),
        serial_number_size_(0),
        serial_number_(),
        comments_size_(0),
        comments_(),
        team_number_(0),
        fpga_button_(0),
        system_active_(0),
        browned_out_(0),
        comms_disable_count_(0),
        rsl_state_(0),
        system_time_valid_(0),
        voltage_vin_(0),
        current_vin_(0),
        user_voltage_3v3_(0),
        user_current_3v3_(0),
        user_active_3v3_(0),
        user_current_faults_3v3_(0),
        user_voltage_5v_(0),
        user_current_5v_(0),
        user_active_5v_(0),
        user_current_faults_5v_(0),
        user_voltage_6v_(0),
        user_current_6v_(0),
        user_active_6v_(0),
        user_current_faults_6v_(0),
        brownout_voltage_(0),
        cpu_temp_(0),
        can_status_(),
        padding0__(0),
        epoch_time_(0) {
    (void)padding0__;
  }
  SystemData(int32_t _fpga_version, int32_t _fpga_revision, uint16_t _serial_number_size, uint16_t _comments_size, int32_t _team_number, int32_t _fpga_button, int32_t _system_active, int32_t _browned_out, int32_t _comms_disable_count, int32_t _rsl_state, int32_t _system_time_valid, double _voltage_vin, double _current_vin, double _user_voltage_3v3, double _user_current_3v3, int32_t _user_active_3v3, int32_t _user_current_faults_3v3, double _user_voltage_5v, double _user_current_5v, int32_t _user_active_5v, int32_t _user_current_faults_5v, double _user_voltage_6v, double _user_current_6v, int32_t _user_active_6v, int32_t _user_current_faults_6v, double _brownout_voltage, double _cpu_temp, const org::littletonrobotics::conduit::schema::CANStatus &_can_status, uint64_t _epoch_time)
      : fpga_version_(::flatbuffers::EndianScalar(_fpga_version)),
        fpga_revision_(::flatbuffers::EndianScalar(_fpga_revision)),
        serial_number_size_(::flatbuffers::EndianScalar(_serial_number_size)),
        serial_number_(),
        comments_size_(::flatbuffers::EndianScalar(_comments_size)),
        comments_(),
        team_number_(::flatbuffers::EndianScalar(_team_number)),
        fpga_button_(::flatbuffers::EndianScalar(_fpga_button)),
        system_active_(::flatbuffers::EndianScalar(_system_active)),
        browned_out_(::flatbuffers::EndianScalar(_browned_out)),
        comms_disable_count_(::flatbuffers::EndianScalar(_comms_disable_count)),
        rsl_state_(::flatbuffers::EndianScalar(_rsl_state)),
        system_time_valid_(::flatbuffers::EndianScalar(_system_time_valid)),
        voltage_vin_(::flatbuffers::EndianScalar(_voltage_vin)),
        current_vin_(::flatbuffers::EndianScalar(_current_vin)),
        user_voltage_3v3_(::flatbuffers::EndianScalar(_user_voltage_3v3)),
        user_current_3v3_(::flatbuffers::EndianScalar(_user_current_3v3)),
        user_active_3v3_(::flatbuffers::EndianScalar(_user_active_3v3)),
        user_current_faults_3v3_(::flatbuffers::EndianScalar(_user_current_faults_3v3)),
        user_voltage_5v_(::flatbuffers::EndianScalar(_user_voltage_5v)),
        user_current_5v_(::flatbuffers::EndianScalar(_user_current_5v)),
        user_active_5v_(::flatbuffers::EndianScalar(_user_active_5v)),
        user_current_faults_5v_(::flatbuffers::EndianScalar(_user_current_faults_5v)),
        user_voltage_6v_(::flatbuffers::EndianScalar(_user_voltage_6v)),
        user_current_6v_(::flatbuffers::EndianScalar(_user_current_6v)),
        user_active_6v_(::flatbuffers::EndianScalar(_user_active_6v)),
        user_current_faults_6v_(::flatbuffers::EndianScalar(_user_current_faults_6v)),
        brownout_voltage_(::flatbuffers::EndianScalar(_brownout_voltage)),
        cpu_temp_(::flatbuffers::EndianScalar(_cpu_temp)),
        can_status_(_can_status),
        padding0__(0),
        epoch_time_(::flatbuffers::EndianScalar(_epoch_time)) {
    (void)padding0__;
  }
  SystemData(int32_t _fpga_version, int32_t _fpga_revision, uint16_t _serial_number_size, ::flatbuffers::span<const uint8_t, 8> _serial_number, uint16_t _comments_size, ::flatbuffers::span<const uint8_t, 64> _comments, int32_t _team_number, int32_t _fpga_button, int32_t _system_active, int32_t _browned_out, int32_t _comms_disable_count, int32_t _rsl_state, int32_t _system_time_valid, double _voltage_vin, double _current_vin, double _user_voltage_3v3, double _user_current_3v3, int32_t _user_active_3v3, int32_t _user_current_faults_3v3, double _user_voltage_5v, double _user_current_5v, int32_t _user_active_5v, int32_t _user_current_faults_5v, double _user_voltage_6v, double _user_current_6v, int32_t _user_active_6v, int32_t _user_current_faults_6v, double _brownout_voltage, double _cpu_temp, const org::littletonrobotics::conduit::schema::CANStatus &_can_status, uint64_t _epoch_time)
      : fpga_version_(::flatbuffers::EndianScalar(_fpga_version)),
        fpga_revision_(::flatbuffers::EndianScalar(_fpga_revision)),
        serial_number_size_(::flatbuffers::EndianScalar(_serial_number_size)),
        comments_size_(::flatbuffers::EndianScalar(_comments_size)),
        team_number_(::flatbuffers::EndianScalar(_team_number)),
        fpga_button_(::flatbuffers::EndianScalar(_fpga_button)),
        system_active_(::flatbuffers::EndianScalar(_system_active)),
        browned_out_(::flatbuffers::EndianScalar(_browned_out)),
        comms_disable_count_(::flatbuffers::EndianScalar(_comms_disable_count)),
        rsl_state_(::flatbuffers::EndianScalar(_rsl_state)),
        system_time_valid_(::flatbuffers::EndianScalar(_system_time_valid)),
        voltage_vin_(::flatbuffers::EndianScalar(_voltage_vin)),
        current_vin_(::flatbuffers::EndianScalar(_current_vin)),
        user_voltage_3v3_(::flatbuffers::EndianScalar(_user_voltage_3v3)),
        user_current_3v3_(::flatbuffers::EndianScalar(_user_current_3v3)),
        user_active_3v3_(::flatbuffers::EndianScalar(_user_active_3v3)),
        user_current_faults_3v3_(::flatbuffers::EndianScalar(_user_current_faults_3v3)),
        user_voltage_5v_(::flatbuffers::EndianScalar(_user_voltage_5v)),
        user_current_5v_(::flatbuffers::EndianScalar(_user_current_5v)),
        user_active_5v_(::flatbuffers::EndianScalar(_user_active_5v)),
        user_current_faults_5v_(::flatbuffers::EndianScalar(_user_current_faults_5v)),
        user_voltage_6v_(::flatbuffers::EndianScalar(_user_voltage_6v)),
        user_current_6v_(::flatbuffers::EndianScalar(_user_current_6v)),
        user_active_6v_(::flatbuffers::EndianScalar(_user_active_6v)),
        user_current_faults_6v_(::flatbuffers::EndianScalar(_user_current_faults_6v)),
        brownout_voltage_(::flatbuffers::EndianScalar(_brownout_voltage)),
        cpu_temp_(::flatbuffers::EndianScalar(_cpu_temp)),
        can_status_(_can_status),
        padding0__(0),
        epoch_time_(::flatbuffers::EndianScalar(_epoch_time)) {
    ::flatbuffers::CastToArray(serial_number_).CopyFromSpan(_serial_number);
    ::flatbuffers::CastToArray(comments_).CopyFromSpan(_comments);
    (void)padding0__;
  }
  int32_t fpga_version() const {
    return ::flatbuffers::EndianScalar(fpga_version_);
  }
  void mutate_fpga_version(int32_t _fpga_version) {
    ::flatbuffers::WriteScalar(&fpga_version_, _fpga_version);
  }
  int32_t fpga_revision() const {
    return ::flatbuffers::EndianScalar(fpga_revision_);
  }
  void mutate_fpga_revision(int32_t _fpga_revision) {
    ::flatbuffers::WriteScalar(&fpga_revision_, _fpga_revision);
  }
  uint16_t serial_number_size() const {
    return ::flatbuffers::EndianScalar(serial_number_size_);
  }
  void mutate_serial_number_size(uint16_t _serial_number_size) {
    ::flatbuffers::WriteScalar(&serial_number_size_, _serial_number_size);
  }
  const ::flatbuffers::Array<uint8_t, 8> *serial_number() const {
    return &::flatbuffers::CastToArray(serial_number_);
  }
  ::flatbuffers::Array<uint8_t, 8> *mutable_serial_number() {
    return &::flatbuffers::CastToArray(serial_number_);
  }
  uint16_t comments_size() const {
    return ::flatbuffers::EndianScalar(comments_size_);
  }
  void mutate_comments_size(uint16_t _comments_size) {
    ::flatbuffers::WriteScalar(&comments_size_, _comments_size);
  }
  const ::flatbuffers::Array<uint8_t, 64> *comments() const {
    return &::flatbuffers::CastToArray(comments_);
  }
  ::flatbuffers::Array<uint8_t, 64> *mutable_comments() {
    return &::flatbuffers::CastToArray(comments_);
  }
  int32_t team_number() const {
    return ::flatbuffers::EndianScalar(team_number_);
  }
  void mutate_team_number(int32_t _team_number) {
    ::flatbuffers::WriteScalar(&team_number_, _team_number);
  }
  int32_t fpga_button() const {
    return ::flatbuffers::EndianScalar(fpga_button_);
  }
  void mutate_fpga_button(int32_t _fpga_button) {
    ::flatbuffers::WriteScalar(&fpga_button_, _fpga_button);
  }
  int32_t system_active() const {
    return ::flatbuffers::EndianScalar(system_active_);
  }
  void mutate_system_active(int32_t _system_active) {
    ::flatbuffers::WriteScalar(&system_active_, _system_active);
  }
  int32_t browned_out() const {
    return ::flatbuffers::EndianScalar(browned_out_);
  }
  void mutate_browned_out(int32_t _browned_out) {
    ::flatbuffers::WriteScalar(&browned_out_, _browned_out);
  }
  int32_t comms_disable_count() const {
    return ::flatbuffers::EndianScalar(comms_disable_count_);
  }
  void mutate_comms_disable_count(int32_t _comms_disable_count) {
    ::flatbuffers::WriteScalar(&comms_disable_count_, _comms_disable_count);
  }
  int32_t rsl_state() const {
    return ::flatbuffers::EndianScalar(rsl_state_);
  }
  void mutate_rsl_state(int32_t _rsl_state) {
    ::flatbuffers::WriteScalar(&rsl_state_, _rsl_state);
  }
  int32_t system_time_valid() const {
    return ::flatbuffers::EndianScalar(system_time_valid_);
  }
  void mutate_system_time_valid(int32_t _system_time_valid) {
    ::flatbuffers::WriteScalar(&system_time_valid_, _system_time_valid);
  }
  double voltage_vin() const {
    return ::flatbuffers::EndianScalar(voltage_vin_);
  }
  void mutate_voltage_vin(double _voltage_vin) {
    ::flatbuffers::WriteScalar(&voltage_vin_, _voltage_vin);
  }
  double current_vin() const {
    return ::flatbuffers::EndianScalar(current_vin_);
  }
  void mutate_current_vin(double _current_vin) {
    ::flatbuffers::WriteScalar(&current_vin_, _current_vin);
  }
  double user_voltage_3v3() const {
    return ::flatbuffers::EndianScalar(user_voltage_3v3_);
  }
  void mutate_user_voltage_3v3(double _user_voltage_3v3) {
    ::flatbuffers::WriteScalar(&user_voltage_3v3_, _user_voltage_3v3);
  }
  double user_current_3v3() const {
    return ::flatbuffers::EndianScalar(user_current_3v3_);
  }
  void mutate_user_current_3v3(double _user_current_3v3) {
    ::flatbuffers::WriteScalar(&user_current_3v3_, _user_current_3v3);
  }
  int32_t user_active_3v3() const {
    return ::flatbuffers::EndianScalar(user_active_3v3_);
  }
  void mutate_user_active_3v3(int32_t _user_active_3v3) {
    ::flatbuffers::WriteScalar(&user_active_3v3_, _user_active_3v3);
  }
  int32_t user_current_faults_3v3() const {
    return ::flatbuffers::EndianScalar(user_current_faults_3v3_);
  }
  void mutate_user_current_faults_3v3(int32_t _user_current_faults_3v3) {
    ::flatbuffers::WriteScalar(&user_current_faults_3v3_, _user_current_faults_3v3);
  }
  double user_voltage_5v() const {
    return ::flatbuffers::EndianScalar(user_voltage_5v_);
  }
  void mutate_user_voltage_5v(double _user_voltage_5v) {
    ::flatbuffers::WriteScalar(&user_voltage_5v_, _user_voltage_5v);
  }
  double user_current_5v() const {
    return ::flatbuffers::EndianScalar(user_current_5v_);
  }
  void mutate_user_current_5v(double _user_current_5v) {
    ::flatbuffers::WriteScalar(&user_current_5v_, _user_current_5v);
  }
  int32_t user_active_5v() const {
    return ::flatbuffers::EndianScalar(user_active_5v_);
  }
  void mutate_user_active_5v(int32_t _user_active_5v) {
    ::flatbuffers::WriteScalar(&user_active_5v_, _user_active_5v);
  }
  int32_t user_current_faults_5v() const {
    return ::flatbuffers::EndianScalar(user_current_faults_5v_);
  }
  void mutate_user_current_faults_5v(int32_t _user_current_faults_5v) {
    ::flatbuffers::WriteScalar(&user_current_faults_5v_, _user_current_faults_5v);
  }
  double user_voltage_6v() const {
    return ::flatbuffers::EndianScalar(user_voltage_6v_);
  }
  void mutate_user_voltage_6v(double _user_voltage_6v) {
    ::flatbuffers::WriteScalar(&user_voltage_6v_, _user_voltage_6v);
  }
  double user_current_6v() const {
    return ::flatbuffers::EndianScalar(user_current_6v_);
  }
  void mutate_user_current_6v(double _user_current_6v) {
    ::flatbuffers::WriteScalar(&user_current_6v_, _user_current_6v);
  }
  int32_t user_active_6v() const {
    return ::flatbuffers::EndianScalar(user_active_6v_);
  }
  void mutate_user_active_6v(int32_t _user_active_6v) {
    ::flatbuffers::WriteScalar(&user_active_6v_, _user_active_6v);
  }
  int32_t user_current_faults_6v() const {
    return ::flatbuffers::EndianScalar(user_current_faults_6v_);
  }
  void mutate_user_current_faults_6v(int32_t _user_current_faults_6v) {
    ::flatbuffers::WriteScalar(&user_current_faults_6v_, _user_current_faults_6v);
  }
  double brownout_voltage() const {
    return ::flatbuffers::EndianScalar(brownout_voltage_);
  }
  void mutate_brownout_voltage(double _brownout_voltage) {
    ::flatbuffers::WriteScalar(&brownout_voltage_, _brownout_voltage);
  }
  double cpu_temp() const {
    return ::flatbuffers::EndianScalar(cpu_temp_);
  }
  void mutate_cpu_temp(double _cpu_temp) {
    ::flatbuffers::WriteScalar(&cpu_temp_, _cpu_temp);
  }
  const org::littletonrobotics::conduit::schema::CANStatus &can_status() const {
    return can_status_;
  }
  org::littletonrobotics::conduit::schema::CANStatus &mutable_can_status() {
    return can_status_;
  }
  uint64_t epoch_time() const {
    return ::flatbuffers::EndianScalar(epoch_time_);
  }
  void mutate_epoch_time(uint64_t _epoch_time) {
    ::flatbuffers::WriteScalar(&epoch_time_, _epoch_time);
  }
};
FLATBUFFERS_STRUCT_END(SystemData, 248);

inline bool operator==(const SystemData &lhs, const SystemData &rhs) {
  return
      (lhs.fpga_version() == rhs.fpga_version()) &&
      (lhs.fpga_revision() == rhs.fpga_revision()) &&
      (lhs.serial_number_size() == rhs.serial_number_size()) &&
      (*lhs.serial_number() == *rhs.serial_number()) &&
      (lhs.comments_size() == rhs.comments_size()) &&
      (*lhs.comments() == *rhs.comments()) &&
      (lhs.team_number() == rhs.team_number()) &&
      (lhs.fpga_button() == rhs.fpga_button()) &&
      (lhs.system_active() == rhs.system_active()) &&
      (lhs.browned_out() == rhs.browned_out()) &&
      (lhs.comms_disable_count() == rhs.comms_disable_count()) &&
      (lhs.rsl_state() == rhs.rsl_state()) &&
      (lhs.system_time_valid() == rhs.system_time_valid()) &&
      (lhs.voltage_vin() == rhs.voltage_vin()) &&
      (lhs.current_vin() == rhs.current_vin()) &&
      (lhs.user_voltage_3v3() == rhs.user_voltage_3v3()) &&
      (lhs.user_current_3v3() == rhs.user_current_3v3()) &&
      (lhs.user_active_3v3() == rhs.user_active_3v3()) &&
      (lhs.user_current_faults_3v3() == rhs.user_current_faults_3v3()) &&
      (lhs.user_voltage_5v() == rhs.user_voltage_5v()) &&
      (lhs.user_current_5v() == rhs.user_current_5v()) &&
      (lhs.user_active_5v() == rhs.user_active_5v()) &&
      (lhs.user_current_faults_5v() == rhs.user_current_faults_5v()) &&
      (lhs.user_voltage_6v() == rhs.user_voltage_6v()) &&
      (lhs.user_current_6v() == rhs.user_current_6v()) &&
      (lhs.user_active_6v() == rhs.user_active_6v()) &&
      (lhs.user_current_faults_6v() == rhs.user_current_faults_6v()) &&
      (lhs.brownout_voltage() == rhs.brownout_voltage()) &&
      (lhs.cpu_temp() == rhs.cpu_temp()) &&
      (lhs.can_status() == rhs.can_status()) &&
      (lhs.epoch_time() == rhs.epoch_time());
}

inline bool operator!=(const SystemData &lhs, const SystemData &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) CoreInputs FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t timestamp_;
  org::littletonrobotics::conduit::schema::DSData ds_;
  org::littletonrobotics::conduit::schema::PDPData pdp_;
  org::littletonrobotics::conduit::schema::SystemData sys_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CoreInputsTypeTable();
  }
  CoreInputs()
      : timestamp_(0),
        ds_(),
        pdp_(),
        sys_() {
  }
  CoreInputs(int64_t _timestamp, const org::littletonrobotics::conduit::schema::DSData &_ds, const org::littletonrobotics::conduit::schema::PDPData &_pdp, const org::littletonrobotics::conduit::schema::SystemData &_sys)
      : timestamp_(::flatbuffers::EndianScalar(_timestamp)),
        ds_(_ds),
        pdp_(_pdp),
        sys_(_sys) {
  }
  int64_t timestamp() const {
    return ::flatbuffers::EndianScalar(timestamp_);
  }
  void mutate_timestamp(int64_t _timestamp) {
    ::flatbuffers::WriteScalar(&timestamp_, _timestamp);
  }
  const org::littletonrobotics::conduit::schema::DSData &ds() const {
    return ds_;
  }
  org::littletonrobotics::conduit::schema::DSData &mutable_ds() {
    return ds_;
  }
  const org::littletonrobotics::conduit::schema::PDPData &pdp() const {
    return pdp_;
  }
  org::littletonrobotics::conduit::schema::PDPData &mutable_pdp() {
    return pdp_;
  }
  const org::littletonrobotics::conduit::schema::SystemData &sys() const {
    return sys_;
  }
  org::littletonrobotics::conduit::schema::SystemData &mutable_sys() {
    return sys_;
  }
};
FLATBUFFERS_STRUCT_END(CoreInputs, 2808);

inline bool operator==(const CoreInputs &lhs, const CoreInputs &rhs) {
  return
      (lhs.timestamp() == rhs.timestamp()) &&
      (lhs.ds() == rhs.ds()) &&
      (lhs.pdp() == rhs.pdp()) &&
      (lhs.sys() == rhs.sys());
}

inline bool operator!=(const CoreInputs &lhs, const CoreInputs &rhs) {
    return !(lhs == rhs);
}


inline const ::flatbuffers::TypeTable *JoystickTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_SHORT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_SHORT, 0, -1 },
    { ::flatbuffers::ET_SHORT, 1, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const int16_t array_sizes[] = { 256, 12, 12, 12,  };
  static const int64_t values[] = { 0, 256, 258, 260, 272, 320, 324, 328, 330, 354, 356 };
  static const char * const names[] = {
    "name",
    "type",
    "axis_count",
    "axis_types",
    "axis_values",
    "button_count",
    "buttons",
    "pov_count",
    "pov_values",
    "is_xbox"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 10, type_codes, nullptr, array_sizes, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DSDataTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_USHORT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_USHORT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    org::littletonrobotics::conduit::schema::JoystickTypeTable
  };
  static const int16_t array_sizes[] = { 64, 64, 6,  };
  static const int64_t values[] = { 0, 4, 68, 70, 134, 136, 140, 144, 152, 160, 2296 };
  static const char * const names[] = {
    "alliance_station",
    "event_name",
    "game_specific_message_size",
    "game_specific_message",
    "match_number",
    "replay_number",
    "match_type",
    "control_word",
    "match_time",
    "joysticks"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 10, type_codes, type_refs, array_sizes, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PDPDataTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 1, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const int16_t array_sizes[] = { 24,  };
  static const int64_t values[] = { 0, 4, 8, 12, 16, 20, 24, 32, 40, 232, 240, 248, 256 };
  static const char * const names[] = {
    "handle",
    "channel_count",
    "type",
    "module_id",
    "faults",
    "sticky_faults",
    "temperature",
    "voltage",
    "channel_current",
    "total_current",
    "total_power",
    "total_energy"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 12, type_codes, nullptr, array_sizes, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CANStatusTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12, 16, 20 };
  static const char * const names[] = {
    "percent_bus_utilization",
    "bus_off_count",
    "tx_full_count",
    "receive_error_count",
    "transmit_error_count"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 5, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SystemDataTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_USHORT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_USHORT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_ULONG, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    org::littletonrobotics::conduit::schema::CANStatusTypeTable
  };
  static const int16_t array_sizes[] = { 8, 64,  };
  static const int64_t values[] = { 0, 4, 8, 10, 18, 20, 84, 88, 92, 96, 100, 104, 108, 112, 120, 128, 136, 144, 148, 152, 160, 168, 172, 176, 184, 192, 196, 200, 208, 216, 240, 248 };
  static const char * const names[] = {
    "fpga_version",
    "fpga_revision",
    "serial_number_size",
    "serial_number",
    "comments_size",
    "comments",
    "team_number",
    "fpga_button",
    "system_active",
    "browned_out",
    "comms_disable_count",
    "rsl_state",
    "system_time_valid",
    "voltage_vin",
    "current_vin",
    "user_voltage_3v3",
    "user_current_3v3",
    "user_active_3v3",
    "user_current_faults_3v3",
    "user_voltage_5v",
    "user_current_5v",
    "user_active_5v",
    "user_current_faults_5v",
    "user_voltage_6v",
    "user_current_6v",
    "user_active_6v",
    "user_current_faults_6v",
    "brownout_voltage",
    "cpu_temp",
    "can_status",
    "epoch_time"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 31, type_codes, type_refs, array_sizes, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CoreInputsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    org::littletonrobotics::conduit::schema::DSDataTypeTable,
    org::littletonrobotics::conduit::schema::PDPDataTypeTable,
    org::littletonrobotics::conduit::schema::SystemDataTypeTable
  };
  static const int64_t values[] = { 0, 8, 2304, 2560, 2808 };
  static const char * const names[] = {
    "timestamp",
    "ds",
    "pdp",
    "sys"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 4, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

}  // namespace schema
}  // namespace conduit
}  // namespace littletonrobotics
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_CONDUITSCHEMA_ORG_LITTLETONROBOTICS_CONDUIT_SCHEMA_H_
